## Chapter 45、General form of Optimization Verification test

**优化验证集的一般形式**

当给定输入x，你知道如何计算表示响应y对输入x有多好的Score_x(y)时，你可以应用优化验证测试。而且，你正在使用近似算法来试图找到`arg max_y Score_x(y)`，但怀疑搜索算法有时不能找到最大值。在我们前面的语音识别示例中，x=A是一个音频剪辑，y=S是输出转录。

假设`y*`是“正确的”输出，但算法输出y_out。那么关键测试是测量是否Score_x(`y*`) > Score_x(y_out)。如果该不等式成立，那么我们会将错误归咎于优化算法。参考前一章以确保你理解其背后的逻辑。否则，我们将归咎于Score_x(y)的计算。

让我们再看一个例子。假设你正在构建一个中译英的机器翻译系统。系统通过输入中文句子C，并为每个可能的翻译E计算Score_c(E)。例如，你可能使用Score_c(E)=P(E|C)，给定输入语句C，翻译为E的概率。

你的算法通过尝试如下计算来翻译句子：

![45](http://oow6unnib.bkt.clouddn.com/myl-c45-0.jpg)

然而，所有可能的英语语句E的集合太大了，所以你依靠启发式搜索算法。

假设你的算法输出错误的翻译E_out，而不是正确的翻译`E*`。那么优化验证测试将要求你计算是否Score_c(`E*`) > Score_c(E_out)。如果该不等式成立，那么Score_c(.)正确地将`E*`识别为比E_out更好的输出；因此，你会将此错误归咎于近似搜索算法。否则，你将此错误归咎于Score_c(.)的计算。

这是AI中一个非常常见的“设计模式”，首先学习一个近似打分函数Score_x(.)，然后使用一个近似最大化算法。如果你能够发现该模式，那么你将能够使用优化验证测试来了解您的错误来源。

